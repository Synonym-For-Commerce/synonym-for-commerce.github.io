{"ast":null,"code":"const pi = Math.PI; //this file is dependent on GSAP core library and my svgGeneric library\n//the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\n//TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\n//centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\n//theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\n//creates a circle from an array of svg paths, returns <g class=\"ring\">\n\nmakeRing = function (pathArr, params) {\n  const ring = params && params[\"ringClass\"] ? group({\n    class: params.ringClass + \" ring\"\n  }) : group({\n    class: \"ring\"\n  });\n  const len = pathArr.length;\n\n  if (len === 1 && pathArr[0] === \"circle\") {\n    //FIXME: should probably have default value for undefined radius\n    return ring.appendChild(circle({\n      r: params.radius,\n      class: \"mandalaCircle\"\n    }));\n  }\n\n  let avgWidth = 0;\n  let avgHeight = 0;\n  let pathDataArr = [];\n  pathArr.forEach(e => {\n    let bBox = e.getBBox(); //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\n\n    if (!bBox.width && !bBox.height) {\n      addToDefs(e);\n      bBox = e.getBBox();\n    }\n\n    avgWidth += bBox.width;\n    avgHeight += bBox.height;\n    pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\n  });\n  avgWidth /= len;\n  avgHeight /= len;\n  let radius = params && params[\"radius\"] ? params.radius : avgHeight;\n  let circumference = radius * 2 * pi;\n  let cuts = params && params[\"cuts\"] ? params.cuts < 1 ? Math.floor(circumference / avgWidth / len) : params.cuts : Math.floor(circumference / avgWidth / len);\n  let totalCuts = cuts * len;\n\n  for (i = 1; i <= totalCuts; i++) {\n    let pathData = pathDataArr[i % len];\n    let partialPath = use({\n      href: `#${pathData[0]}`,\n      class: pathData[1]\n    }); //center\n\n    gsapCenterElement(partialPath); //move to circumference\n\n    var angleRad = 2 * pi * i / totalCuts;\n    let scale = params && params[\"scale\"] ? params.scale : 1;\n    gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\n    ring.appendChild(partialPath);\n  }\n\n  if (params && params[\"ringOffset\"]) gsap.set(ring, {\n    transformOrigin: \"center\",\n    rotation: params.ringOffset\n  });\n  return ring;\n}; //centers an svg element\n\n\ngsapCenterElement = function (elem) {\n  //requires the element to exist within the dom so bBox is not 0,\n  addToDefs(elem);\n  let bBox = elem.getBBox();\n  gsap.set(elem, {\n    x: `-=${bBox.width / 2 + bBox.x}px`,\n    y: `-=${bBox.height / 2 + bBox.y}px`\n  });\n}; //moves an element to a some point in an imaginary circle surrounding the element\n\n\ngsapMoveToCircumferenceAtAngle = function (elem, angleRad, radius, scale) {\n  gsap.set(elem, {\n    transformOrigin: \"center\",\n    x: `+=${radius * Math.sin(angleRad)}px`,\n    y: `-=${radius * Math.cos(angleRad)}px`,\n    rotation: `${angleRad}rad`,\n    scale: scale\n  });\n}; //creates a series of rings using makeRing function\n//first param is an arra of arrays the inner arrays are to be comprised of svg paths\n//second param is an array or parameters relating to each ring; radius, cuts, ringClass\n//third param is params relating to the overall system of concentric rings; concentricSystem\n\n\nmakeConcentricRings = function (pathArrArr, paramArr, params) {\n  let concentricSystem = params && params[\"concentricSystem\"] ? params.concentricSystem : group({\n    id: params.id\n  });\n  pathArrArr.forEach((elemArr, index) => {\n    let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\n    concentricSystem.appendChild(ring);\n  });\n  return concentricSystem;\n};","map":{"version":3,"sources":["C:/Users/Soda/Documents/HTML5/mandala-maker/src/js/mandala.js"],"names":["pi","Math","PI","makeRing","pathArr","params","ring","group","class","ringClass","len","length","appendChild","circle","r","radius","avgWidth","avgHeight","pathDataArr","forEach","e","bBox","getBBox","width","height","addToDefs","push","getAttribute","circumference","cuts","floor","totalCuts","i","pathData","partialPath","use","href","gsapCenterElement","angleRad","scale","gsapMoveToCircumferenceAtAngle","gsap","set","transformOrigin","rotation","ringOffset","elem","x","y","sin","cos","makeConcentricRings","pathArrArr","paramArr","concentricSystem","id","elemArr","index"],"mappings":"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","sourcesContent":["const pi = Math.PI;\r\n//this file is dependent on GSAP core library and my svgGeneric library\r\n//the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\r\n//TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\r\n//centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\r\n//theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\r\n\r\n//creates a circle from an array of svg paths, returns <g class=\"ring\">\r\nmakeRing = function (pathArr, params) {\r\n  const ring =\r\n    params && params[\"ringClass\"]\r\n      ? group({ class: params.ringClass + \" ring\" })\r\n      : group({ class: \"ring\" });\r\n  const len = pathArr.length;\r\n  if (len === 1 && pathArr[0] === \"circle\") {\r\n    //FIXME: should probably have default value for undefined radius\r\n    return ring.appendChild(\r\n      circle({ r: params.radius, class: \"mandalaCircle\" })\r\n    );\r\n  }\r\n  let avgWidth = 0;\r\n  let avgHeight = 0;\r\n  let pathDataArr = [];\r\n  pathArr.forEach((e) => {\r\n    let bBox = e.getBBox();\r\n    //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\r\n    if (!bBox.width && !bBox.height) {\r\n      addToDefs(e);\r\n      bBox = e.getBBox();\r\n    }\r\n    avgWidth += bBox.width;\r\n    avgHeight += bBox.height;\r\n    pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\r\n  });\r\n  avgWidth /= len;\r\n  avgHeight /= len;\r\n  let radius = params && params[\"radius\"] ? params.radius : avgHeight;\r\n  let circumference = radius * 2 * pi;\r\n  let cuts =\r\n    params && params[\"cuts\"]\r\n      ? params.cuts < 1\r\n        ? Math.floor(circumference / avgWidth / len)\r\n        : params.cuts\r\n      : Math.floor(circumference / avgWidth / len);\r\n  let totalCuts = cuts * len;\r\n\r\n  for (i = 1; i <= totalCuts; i++) {\r\n    let pathData = pathDataArr[i % len];\r\n    let partialPath = use({\r\n      href: `#${pathData[0]}`,\r\n      class: pathData[1],\r\n    });\r\n\r\n    //center\r\n    gsapCenterElement(partialPath);\r\n    //move to circumference\r\n    var angleRad = (2 * pi * i) / totalCuts;\r\n    let scale = params && params[\"scale\"] ? params.scale : 1;\r\n    gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\r\n    ring.appendChild(partialPath);\r\n  }\r\n  if (params && params[\"ringOffset\"])\r\n    gsap.set(ring, { transformOrigin: \"center\", rotation: params.ringOffset });\r\n  return ring;\r\n};\r\n\r\n//centers an svg element\r\ngsapCenterElement = function (elem) {\r\n  //requires the element to exist within the dom so bBox is not 0,\r\n  addToDefs(elem);\r\n  let bBox = elem.getBBox();\r\n  gsap.set(elem, {\r\n    x: `-=${bBox.width / 2 + bBox.x}px`,\r\n    y: `-=${bBox.height / 2 + bBox.y}px`,\r\n  });\r\n};\r\n\r\n//moves an element to a some point in an imaginary circle surrounding the element\r\ngsapMoveToCircumferenceAtAngle = function (elem, angleRad, radius, scale) {\r\n  gsap.set(elem, {\r\n    transformOrigin: \"center\",\r\n    x: `+=${radius * Math.sin(angleRad)}px`,\r\n    y: `-=${radius * Math.cos(angleRad)}px`,\r\n    rotation: `${angleRad}rad`,\r\n    scale: scale,\r\n  });\r\n};\r\n//creates a series of rings using makeRing function\r\n//first param is an arra of arrays the inner arrays are to be comprised of svg paths\r\n//second param is an array or parameters relating to each ring; radius, cuts, ringClass\r\n//third param is params relating to the overall system of concentric rings; concentricSystem\r\nmakeConcentricRings = function (pathArrArr, paramArr, params) {\r\n  let concentricSystem =\r\n    params && params[\"concentricSystem\"]\r\n      ? params.concentricSystem\r\n      : group({ id: params.id });\r\n  pathArrArr.forEach((elemArr, index) => {\r\n    let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\r\n    concentricSystem.appendChild(ring);\r\n  });\r\n  return concentricSystem;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}
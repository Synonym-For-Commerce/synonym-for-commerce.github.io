{"ast":null,"code":"import React, { Component } from \"react\";\nimport gsap from \"gsap\";\nimport * as svgGeneric from \"./svgGeneric\";\nconst pi = Math.PI; // class mandala extends Component {\n//this file is dependent on GSAP core library and my svgGeneric library\n//the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\n//TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\n//centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\n//theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\n//creates a circle from an array of svg paths, returns <g class=\"ring\">\n\nexport function makeRing(pathArr, params) {\n  const ring = params && params[\"ringClass\"] ? svgGeneric.group({\n    class: params.ringClass + \" ring\"\n  }) : svgGeneric.group({\n    class: \"ring\"\n  });\n  const len = pathArr.length;\n\n  if (len === 1 && pathArr[0] === \"circle\") {\n    //FIXME: should probably have default value for undefined radius\n    return ring.appendChild(svgGeneric.circle({\n      r: params.radius,\n      class: \"mandalaCircle\"\n    }));\n  }\n\n  let avgWidth = 0;\n  let avgHeight = 0;\n  let pathDataArr = [];\n  pathArr.forEach(e => {\n    console.log(e);\n    let bBox = e.getBBox(); //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\n\n    if (!bBox.width && !bBox.height) {\n      svgGeneric.addToDefs(e);\n      bBox = e.getBBox();\n    }\n\n    avgWidth += bBox.width;\n    avgHeight += bBox.height;\n    pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\n  });\n  avgWidth /= len;\n  avgHeight /= len;\n  let radius = params && params[\"radius\"] ? params.radius : avgHeight;\n  let circumference = radius * 2 * pi;\n  let cuts = params && params[\"cuts\"] ? params.cuts < 1 ? Math.floor(circumference / avgWidth / len) : params.cuts : Math.floor(circumference / avgWidth / len);\n  let totalCuts = cuts * len;\n\n  for (let i = 1; i <= totalCuts; i++) {\n    let pathData = pathDataArr[i % len];\n    let partialPath = svgGeneric.use({\n      href: `#${pathData[0]}`,\n      class: pathData[1]\n    }); //center\n\n    this.gsapCenterElement(partialPath); //move to circumference\n\n    var angleRad = 2 * pi * i / totalCuts;\n    let scale = params && params[\"scale\"] ? params.scale : 1;\n    this.gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\n    ring.appendChild(partialPath);\n  }\n\n  if (params && params[\"ringOffset\"]) gsap.set(ring, {\n    transformOrigin: \"center\",\n    rotation: params.ringOffset\n  });\n  return ring;\n}\n; //centers an svg element\n\nfunction gsapCenterElement(elem) {\n  //requires the element to exist within the dom so bBox is not 0,\n  svgGeneric.addToDefs(elem);\n  let bBox = elem.getBBox();\n  gsap.set(elem, {\n    x: `-=${bBox.width / 2 + bBox.x}px`,\n    y: `-=${bBox.height / 2 + bBox.y}px`\n  });\n}\n\n; //moves an element to a some point in an imaginary circle surrounding the element\n\nfunction gsapMoveToCircumferenceAtAngle(elem, angleRad, radius, scale) {\n  gsap.set(elem, {\n    transformOrigin: \"center\",\n    x: `+=${radius * Math.sin(angleRad)}px`,\n    y: `-=${radius * Math.cos(angleRad)}px`,\n    rotation: `${angleRad}rad`,\n    scale: scale\n  });\n}\n\n; //creates a series of rings using makeRing function\n//first param is an arra of arrays the inner arrays are to be comprised of svg paths\n//second param is an array or parameters relating to each ring; radius, cuts, ringClass\n//third param is params relating to the overall system of concentric rings; concentricSystem\n\nexport default function makeConcentricRings(pathArrArr, paramArr, params) {\n  let concentricSystem = params && params[\"concentricSystem\"] ? params.concentricSystem : svgGeneric.group({\n    id: params.id\n  });\n  pathArrArr.forEach((elemArr, index) => {\n    let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\n    concentricSystem.appendChild(ring);\n  });\n  return concentricSystem;\n}\n; // }\n// export default mandala;","map":{"version":3,"sources":["C:/Users/Soda/Documents/HTML5/mandala-maker/src/js/mandala.js"],"names":["React","Component","gsap","svgGeneric","pi","Math","PI","makeRing","pathArr","params","ring","group","class","ringClass","len","length","appendChild","circle","r","radius","avgWidth","avgHeight","pathDataArr","forEach","e","console","log","bBox","getBBox","width","height","addToDefs","push","getAttribute","circumference","cuts","floor","totalCuts","i","pathData","partialPath","use","href","gsapCenterElement","angleRad","scale","gsapMoveToCircumferenceAtAngle","set","transformOrigin","rotation","ringOffset","elem","x","y","sin","cos","makeConcentricRings","pathArrArr","paramArr","concentricSystem","id","elemArr","index"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport gsap from \"gsap\";\r\nimport * as svgGeneric from \"./svgGeneric\";\r\nconst pi = Math.PI;\r\n\r\n// class mandala extends Component {\r\n  //this file is dependent on GSAP core library and my svgGeneric library\r\n  //the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\r\n  //TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\r\n  //centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\r\n  //theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\r\n\r\n  //creates a circle from an array of svg paths, returns <g class=\"ring\">\r\n  export function makeRing (pathArr, params) {\r\n    const ring =\r\n      params && params[\"ringClass\"]\r\n        ? svgGeneric.group({ class: params.ringClass + \" ring\" })\r\n        : svgGeneric.group({ class: \"ring\" });\r\n    const len = pathArr.length;\r\n    if (len === 1 && pathArr[0] === \"circle\") {\r\n      //FIXME: should probably have default value for undefined radius\r\n      return ring.appendChild(\r\n        svgGeneric.circle({ r: params.radius, class: \"mandalaCircle\" })\r\n      );\r\n    }\r\n    let avgWidth = 0;\r\n    let avgHeight = 0;\r\n    let pathDataArr = [];\r\n    pathArr.forEach((e) => {\r\n      console.log(e);\r\n      let bBox = e.getBBox();\r\n      //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\r\n      if (!bBox.width && !bBox.height) {\r\n        svgGeneric.addToDefs(e);\r\n        bBox = e.getBBox();\r\n      }\r\n      avgWidth += bBox.width;\r\n      avgHeight += bBox.height;\r\n      pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\r\n    });\r\n    avgWidth /= len;\r\n    avgHeight /= len;\r\n    let radius = params && params[\"radius\"] ? params.radius : avgHeight;\r\n    let circumference = radius * 2 * pi;\r\n    let cuts =\r\n      params && params[\"cuts\"]\r\n        ? params.cuts < 1\r\n          ? Math.floor(circumference / avgWidth / len)\r\n          : params.cuts\r\n        : Math.floor(circumference / avgWidth / len);\r\n    let totalCuts = cuts * len;\r\n\r\n    for (let i = 1; i <= totalCuts; i++) {\r\n      let pathData = pathDataArr[i % len];\r\n      let partialPath = svgGeneric.use({\r\n        href: `#${pathData[0]}`,\r\n        class: pathData[1],\r\n      });\r\n\r\n      //center\r\n      this.gsapCenterElement(partialPath);\r\n      //move to circumference\r\n      var angleRad = (2 * pi * i) / totalCuts;\r\n      let scale = params && params[\"scale\"] ? params.scale : 1;\r\n      this.gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\r\n      ring.appendChild(partialPath);\r\n    }\r\n    if (params && params[\"ringOffset\"])\r\n      gsap.set(ring, {\r\n        transformOrigin: \"center\",\r\n        rotation: params.ringOffset,\r\n      });\r\n    return ring;\r\n  };\r\n\r\n  //centers an svg element\r\n  function gsapCenterElement (elem) {\r\n    //requires the element to exist within the dom so bBox is not 0,\r\n    svgGeneric.addToDefs(elem);\r\n    let bBox = elem.getBBox();\r\n    gsap.set(elem, {\r\n      x: `-=${bBox.width / 2 + bBox.x}px`,\r\n      y: `-=${bBox.height / 2 + bBox.y}px`,\r\n    });\r\n  };\r\n\r\n  //moves an element to a some point in an imaginary circle surrounding the element\r\n  function gsapMoveToCircumferenceAtAngle (elem, angleRad, radius, scale) {\r\n    gsap.set(elem, {\r\n      transformOrigin: \"center\",\r\n      x: `+=${radius * Math.sin(angleRad)}px`,\r\n      y: `-=${radius * Math.cos(angleRad)}px`,\r\n      rotation: `${angleRad}rad`,\r\n      scale: scale,\r\n    });\r\n  };\r\n  //creates a series of rings using makeRing function\r\n  //first param is an arra of arrays the inner arrays are to be comprised of svg paths\r\n  //second param is an array or parameters relating to each ring; radius, cuts, ringClass\r\n  //third param is params relating to the overall system of concentric rings; concentricSystem\r\n  export default function makeConcentricRings (pathArrArr, paramArr, params) {\r\n    let concentricSystem =\r\n      params && params[\"concentricSystem\"]\r\n        ? params.concentricSystem\r\n        : svgGeneric.group({ id: params.id });\r\n    pathArrArr.forEach((elemArr, index) => {\r\n      let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\r\n      concentricSystem.appendChild(ring);\r\n    });\r\n    return concentricSystem;\r\n  };\r\n// }\r\n// export default mandala;\r\n"]},"metadata":{},"sourceType":"module"}
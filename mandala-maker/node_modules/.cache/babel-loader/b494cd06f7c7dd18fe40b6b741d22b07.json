{"ast":null,"code":"import React, { Component } from \"react\";\nimport gsap from \"gsap\";\nconst pi = Math.PI;\nexport default class extends Component {\n  constructor(...args) {\n    super(...args);\n\n    this.makeRing = function (pathArr, params) {\n      const ring = params && params[\"ringClass\"] ? group({\n        class: params.ringClass + \" ring\"\n      }) : group({\n        class: \"ring\"\n      });\n      const len = pathArr.length;\n\n      if (len === 1 && pathArr[0] === \"circle\") {\n        //FIXME: should probably have default value for undefined radius\n        return ring.appendChild(circle({\n          r: params.radius,\n          class: \"mandalaCircle\"\n        }));\n      }\n\n      let avgWidth = 0;\n      let avgHeight = 0;\n      let pathDataArr = [];\n      pathArr.forEach(e => {\n        let bBox = e.getBBox(); //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\n\n        if (!bBox.width && !bBox.height) {\n          addToDefs(e);\n          bBox = e.getBBox();\n        }\n\n        avgWidth += bBox.width;\n        avgHeight += bBox.height;\n        pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\n      });\n      avgWidth /= len;\n      avgHeight /= len;\n      let radius = params && params[\"radius\"] ? params.radius : avgHeight;\n      let circumference = radius * 2 * pi;\n      let cuts = params && params[\"cuts\"] ? params.cuts < 1 ? Math.floor(circumference / avgWidth / len) : params.cuts : Math.floor(circumference / avgWidth / len);\n      let totalCuts = cuts * len;\n\n      for (i = 1; i <= totalCuts; i++) {\n        let pathData = pathDataArr[i % len];\n        let partialPath = use({\n          href: `#${pathData[0]}`,\n          class: pathData[1]\n        }); //center\n\n        gsapCenterElement(partialPath); //move to circumference\n\n        var angleRad = 2 * pi * i / totalCuts;\n        let scale = params && params[\"scale\"] ? params.scale : 1;\n        gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\n        ring.appendChild(partialPath);\n      }\n\n      if (params && params[\"ringOffset\"]) gsap.set(ring, {\n        transformOrigin: \"center\",\n        rotation: params.ringOffset\n      });\n      return ring;\n    };\n\n    this.gsapCenterElement = function (elem) {\n      //requires the element to exist within the dom so bBox is not 0,\n      addToDefs(elem);\n      let bBox = elem.getBBox();\n      gsap.set(elem, {\n        x: `-=${bBox.width / 2 + bBox.x}px`,\n        y: `-=${bBox.height / 2 + bBox.y}px`\n      });\n    };\n\n    this.gsapMoveToCircumferenceAtAngle = function (elem, angleRad, radius, scale) {\n      gsap.set(elem, {\n        transformOrigin: \"center\",\n        x: `+=${radius * Math.sin(angleRad)}px`,\n        y: `-=${radius * Math.cos(angleRad)}px`,\n        rotation: `${angleRad}rad`,\n        scale: scale\n      });\n    };\n\n    this.makeConcentricRings = function (pathArrArr, paramArr, params) {\n      let concentricSystem = params && params[\"concentricSystem\"] ? params.concentricSystem : group({\n        id: params.id\n      });\n      pathArrArr.forEach((elemArr, index) => {\n        let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\n        concentricSystem.appendChild(ring);\n      });\n      return concentricSystem;\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/Soda/Documents/HTML5/mandala-maker/src/js/mandala.js"],"names":["React","Component","gsap","pi","Math","PI","makeRing","pathArr","params","ring","group","class","ringClass","len","length","appendChild","circle","r","radius","avgWidth","avgHeight","pathDataArr","forEach","e","bBox","getBBox","width","height","addToDefs","push","getAttribute","circumference","cuts","floor","totalCuts","i","pathData","partialPath","use","href","gsapCenterElement","angleRad","scale","gsapMoveToCircumferenceAtAngle","set","transformOrigin","rotation","ringOffset","elem","x","y","sin","cos","makeConcentricRings","pathArrArr","paramArr","concentricSystem","id","elemArr","index"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport gsap from \"gsap\";\r\nconst pi = Math.PI;\r\nexport default class extends Component {\r\n  //this file is dependent on GSAP core library and my svgGeneric library\r\n  //the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\r\n  //TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\r\n  //centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\r\n  //theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\r\n\r\n  //creates a circle from an array of svg paths, returns <g class=\"ring\">\r\n  makeRing = function (pathArr, params) {\r\n    const ring =\r\n      params && params[\"ringClass\"]\r\n        ? group({ class: params.ringClass + \" ring\" })\r\n        : group({ class: \"ring\" });\r\n    const len = pathArr.length;\r\n    if (len === 1 && pathArr[0] === \"circle\") {\r\n      //FIXME: should probably have default value for undefined radius\r\n      return ring.appendChild(\r\n        circle({ r: params.radius, class: \"mandalaCircle\" })\r\n      );\r\n    }\r\n    let avgWidth = 0;\r\n    let avgHeight = 0;\r\n    let pathDataArr = [];\r\n    pathArr.forEach((e) => {\r\n      let bBox = e.getBBox();\r\n      //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\r\n      if (!bBox.width && !bBox.height) {\r\n        addToDefs(e);\r\n        bBox = e.getBBox();\r\n      }\r\n      avgWidth += bBox.width;\r\n      avgHeight += bBox.height;\r\n      pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\r\n    });\r\n    avgWidth /= len;\r\n    avgHeight /= len;\r\n    let radius = params && params[\"radius\"] ? params.radius : avgHeight;\r\n    let circumference = radius * 2 * pi;\r\n    let cuts =\r\n      params && params[\"cuts\"]\r\n        ? params.cuts < 1\r\n          ? Math.floor(circumference / avgWidth / len)\r\n          : params.cuts\r\n        : Math.floor(circumference / avgWidth / len);\r\n    let totalCuts = cuts * len;\r\n\r\n    for (i = 1; i <= totalCuts; i++) {\r\n      let pathData = pathDataArr[i % len];\r\n      let partialPath = use({\r\n        href: `#${pathData[0]}`,\r\n        class: pathData[1],\r\n      });\r\n\r\n      //center\r\n      gsapCenterElement(partialPath);\r\n      //move to circumference\r\n      var angleRad = (2 * pi * i) / totalCuts;\r\n      let scale = params && params[\"scale\"] ? params.scale : 1;\r\n      gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\r\n      ring.appendChild(partialPath);\r\n    }\r\n    if (params && params[\"ringOffset\"])\r\n      gsap.set(ring, {\r\n        transformOrigin: \"center\",\r\n        rotation: params.ringOffset,\r\n      });\r\n    return ring;\r\n  };\r\n\r\n  //centers an svg element\r\n  gsapCenterElement = function (elem) {\r\n    //requires the element to exist within the dom so bBox is not 0,\r\n    addToDefs(elem);\r\n    let bBox = elem.getBBox();\r\n    gsap.set(elem, {\r\n      x: `-=${bBox.width / 2 + bBox.x}px`,\r\n      y: `-=${bBox.height / 2 + bBox.y}px`,\r\n    });\r\n  };\r\n\r\n  //moves an element to a some point in an imaginary circle surrounding the element\r\n  gsapMoveToCircumferenceAtAngle = function (elem, angleRad, radius, scale) {\r\n    gsap.set(elem, {\r\n      transformOrigin: \"center\",\r\n      x: `+=${radius * Math.sin(angleRad)}px`,\r\n      y: `-=${radius * Math.cos(angleRad)}px`,\r\n      rotation: `${angleRad}rad`,\r\n      scale: scale,\r\n    });\r\n  };\r\n  //creates a series of rings using makeRing function\r\n  //first param is an arra of arrays the inner arrays are to be comprised of svg paths\r\n  //second param is an array or parameters relating to each ring; radius, cuts, ringClass\r\n  //third param is params relating to the overall system of concentric rings; concentricSystem\r\n  makeConcentricRings = function (pathArrArr, paramArr, params) {\r\n    let concentricSystem =\r\n      params && params[\"concentricSystem\"]\r\n        ? params.concentricSystem\r\n        : group({ id: params.id });\r\n    pathArrArr.forEach((elemArr, index) => {\r\n      let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\r\n      concentricSystem.appendChild(ring);\r\n    });\r\n    return concentricSystem;\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}
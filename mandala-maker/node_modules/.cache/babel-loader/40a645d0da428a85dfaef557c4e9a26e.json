{"ast":null,"code":"import React, { Component } from \"react\";\nimport gsap from \"gsap\";\nimport * as svgGeneric from \"./svgGeneric\";\nconst pi = Math.PI; // class mandala extends Component {\n//this file is dependent on GSAP core library and my svgGeneric library\n//the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\n//TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\n//centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\n//theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\n//creates a circle from an array of svg paths, returns <g class=\"ring\">\n\nexport function makeRing(pathArr, params) {\n  const ring = params && params[\"ringClass\"] ? svgGeneric.group({\n    className: params.ringClass + \" ring\"\n  }) : svgGeneric.group({\n    className: \"ring\"\n  });\n  const len = pathArr.length;\n\n  if (len === 1 && pathArr[0] === \"circle\") {\n    //FIXME: should probably have default value for undefined radius\n    return ring.appendChild(svgGeneric.circle({\n      r: params.radius,\n      class: \"mandalaCircle\"\n    }));\n  }\n\n  let avgWidth = 0;\n  let avgHeight = 0;\n  let pathDataArr = [];\n  pathArr.forEach(e => {\n    let bBox = e.getBBox(); //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\n\n    if (!bBox.width && !bBox.height) {\n      svgGeneric.addToDefs(e);\n      bBox = e.getBBox();\n    }\n\n    avgWidth += bBox.width;\n    avgHeight += bBox.height;\n    pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\n  });\n  avgWidth /= len;\n  avgHeight /= len;\n  let radius = params && params[\"radius\"] ? params.radius : avgHeight;\n  let circumference = radius * 2 * pi;\n  let cuts = params && params[\"cuts\"] ? params.cuts < 1 ? Math.floor(circumference / avgWidth / len) : params.cuts : Math.floor(circumference / avgWidth / len);\n  let totalCuts = cuts * len;\n\n  for (let i = 1; i <= totalCuts; i++) {\n    let pathData = pathDataArr[i % len];\n    let partialPath = svgGeneric.use({\n      href: `#${pathData[0]}`,\n      class: pathData[1]\n    }); //center\n\n    gsapCenterElement(partialPath); //move to circumference\n\n    var angleRad = 2 * pi * i / totalCuts;\n    let scale = params && params[\"scale\"] ? params.scale : 1;\n    gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\n    ring.appendChild(partialPath);\n  }\n\n  if (params && params[\"ringOffset\"]) gsap.set(ring, {\n    transformOrigin: \"center\",\n    rotation: params.ringOffset\n  });\n  return ring;\n}\n; //centers an svg element\n\nfunction gsapCenterElement(elem) {\n  //requires the element to exist within the dom so bBox is not 0,\n  svgGeneric.addToDefs(elem);\n  let bBox = elem.getBBox();\n  gsap.set(elem, {\n    x: `-=${bBox.width / 2 + bBox.x}px`,\n    y: `-=${bBox.height / 2 + bBox.y}px`\n  });\n}\n\n; //moves an element to a some point in an imaginary circle surrounding the element\n\nfunction gsapMoveToCircumferenceAtAngle(elem, angleRad, radius, scale) {\n  gsap.set(elem, {\n    transformOrigin: \"center\",\n    x: `+=${radius * Math.sin(angleRad)}px`,\n    y: `-=${radius * Math.cos(angleRad)}px`,\n    rotation: `${angleRad}rad`,\n    scale: scale\n  });\n}\n\n; //creates a series of rings using makeRing function\n//first param is an arra of arrays the inner arrays are to be comprised of svg paths\n//second param is an array or parameters relating to each ring; radius, cuts, ringClass\n//third param is params relating to the overall system of concentric rings; concentricSystem\n\nexport default function makeConcentricRings(pathArrArr, paramArr, params) {\n  let concentricSystem = params && params[\"concentricSystem\"] ? params.concentricSystem : svgGeneric.group({\n    id: params.id\n  });\n  pathArrArr.forEach((elemArr, index) => {\n    let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\n    concentricSystem.appendChild(ring);\n  });\n  return concentricSystem;\n}\n; // }\n// export default mandala;","map":{"version":3,"sources":["C:/Users/Soda/Documents/HTML5/mandala-maker/src/js/mandala.js"],"names":["React","Component","gsap","svgGeneric","pi","Math","PI","makeRing","pathArr","params","ring","group","className","ringClass","len","length","appendChild","circle","r","radius","class","avgWidth","avgHeight","pathDataArr","forEach","e","bBox","getBBox","width","height","addToDefs","push","getAttribute","circumference","cuts","floor","totalCuts","i","pathData","partialPath","use","href","gsapCenterElement","angleRad","scale","gsapMoveToCircumferenceAtAngle","set","transformOrigin","rotation","ringOffset","elem","x","y","sin","cos","makeConcentricRings","pathArrArr","paramArr","concentricSystem","id","elemArr","index"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\r\nimport gsap from \"gsap\";\r\nimport * as svgGeneric from \"./svgGeneric\";\r\nconst pi = Math.PI;\r\n\r\n// class mandala extends Component {\r\n  //this file is dependent on GSAP core library and my svgGeneric library\r\n  //the purpose of this file is to facilitate the creation of mandala type patterns from svg paths,\r\n  //TODO: flatten the paths on each ring so there isnt one on top of the others.. but i dont wanna even think about the frigggin math involved in that nonsense, also involves switching betweeen <use> and <path>, not ideal\r\n  //centering doesnt work in other browsers do a stupid fucking platform bullshit goddamit test thing\r\n  //theres like, zero, exception handling in this bitch. passing anything other than the expected arrays or params into any of the functions will cause it to crap its pants\r\n\r\n  //creates a circle from an array of svg paths, returns <g class=\"ring\">\r\n  export function makeRing (pathArr, params) {\r\n    const ring =\r\n      params && params[\"ringClass\"]\r\n        ? svgGeneric.group({ className: params.ringClass + \" ring\" })\r\n        : svgGeneric.group({ className: \"ring\" });\r\n    const len = pathArr.length;\r\n    if (len === 1 && pathArr[0] === \"circle\") {\r\n      //FIXME: should probably have default value for undefined radius\r\n      return ring.appendChild(\r\n        svgGeneric.circle({ r: params.radius, class: \"mandalaCircle\" })\r\n      );\r\n    }\r\n    let avgWidth = 0;\r\n    let avgHeight = 0;\r\n    let pathDataArr = [];\r\n    pathArr.forEach((e) => {\r\n      let bBox = e.getBBox();\r\n      //any elements passed in that are not in dom will be added to defs, as will any elements in the dom that have height == 0 and width == 0\r\n      if (!bBox.width && !bBox.height) {\r\n        svgGeneric.addToDefs(e);\r\n        bBox = e.getBBox();\r\n      }\r\n      avgWidth += bBox.width;\r\n      avgHeight += bBox.height;\r\n      pathDataArr.push([e.getAttribute(\"id\"), e.getAttribute(\"class\")]);\r\n    });\r\n    avgWidth /= len;\r\n    avgHeight /= len;\r\n    let radius = params && params[\"radius\"] ? params.radius : avgHeight;\r\n    let circumference = radius * 2 * pi;\r\n    let cuts =\r\n      params && params[\"cuts\"]\r\n        ? params.cuts < 1\r\n          ? Math.floor(circumference / avgWidth / len)\r\n          : params.cuts\r\n        : Math.floor(circumference / avgWidth / len);\r\n    let totalCuts = cuts * len;\r\n\r\n    for (let i = 1; i <= totalCuts; i++) {\r\n      let pathData = pathDataArr[i % len];\r\n      let partialPath = svgGeneric.use({\r\n        href: `#${pathData[0]}`,\r\n        class: pathData[1],\r\n      });\r\n\r\n      //center\r\n      gsapCenterElement(partialPath);\r\n      //move to circumference\r\n      var angleRad = (2 * pi * i) / totalCuts;\r\n      let scale = params && params[\"scale\"] ? params.scale : 1;\r\n      gsapMoveToCircumferenceAtAngle(partialPath, angleRad, radius, scale);\r\n      ring.appendChild(partialPath);\r\n    }\r\n    if (params && params[\"ringOffset\"])\r\n      gsap.set(ring, {\r\n        transformOrigin: \"center\",\r\n        rotation: params.ringOffset,\r\n      });\r\n    return ring;\r\n  };\r\n\r\n  //centers an svg element\r\n  function gsapCenterElement (elem) {\r\n    //requires the element to exist within the dom so bBox is not 0,\r\n    svgGeneric.addToDefs(elem);\r\n    let bBox = elem.getBBox();\r\n    gsap.set(elem, {\r\n      x: `-=${bBox.width / 2 + bBox.x}px`,\r\n      y: `-=${bBox.height / 2 + bBox.y}px`,\r\n    });\r\n  };\r\n\r\n  //moves an element to a some point in an imaginary circle surrounding the element\r\n  function gsapMoveToCircumferenceAtAngle (elem, angleRad, radius, scale) {\r\n    gsap.set(elem, {\r\n      transformOrigin: \"center\",\r\n      x: `+=${radius * Math.sin(angleRad)}px`,\r\n      y: `-=${radius * Math.cos(angleRad)}px`,\r\n      rotation: `${angleRad}rad`,\r\n      scale: scale,\r\n    });\r\n  };\r\n  //creates a series of rings using makeRing function\r\n  //first param is an arra of arrays the inner arrays are to be comprised of svg paths\r\n  //second param is an array or parameters relating to each ring; radius, cuts, ringClass\r\n  //third param is params relating to the overall system of concentric rings; concentricSystem\r\n  export default function makeConcentricRings (pathArrArr, paramArr, params) {\r\n    let concentricSystem =\r\n      params && params[\"concentricSystem\"]\r\n        ? params.concentricSystem\r\n        : svgGeneric.group({ id: params.id });\r\n    pathArrArr.forEach((elemArr, index) => {\r\n      let ring = makeRing(elemArr, paramArr[index % paramArr.length]);\r\n      concentricSystem.appendChild(ring);\r\n    });\r\n    return concentricSystem;\r\n  };\r\n// }\r\n// export default mandala;\r\n"]},"metadata":{},"sourceType":"module"}